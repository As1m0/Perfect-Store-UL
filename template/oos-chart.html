<div class="chart-container">
    <h4 class="text-center mt-3">Out of Stock report</h4>
    <div class="text-center mb-3">
        <label class="text-muted small" for="periodSelect">Period:</label>
        <select class="mr-1" type="select" id="periodSelect" name="periodSelect">
            <option value="daily">Daily</option>
            <option value="weekly" selected>Weekly</option>
            <option value="monthly">Montly</option>
            <option value="yearly">Yearly</option>
        </select>
        <label class="text-muted small" for="startDate">Start Date:</label>
        <input type="date" class="date-input" id="startDate" name="startDate" value="">
        <label class="text-muted small" for="endDate">End Date:</label>
        <input type="date" class="date-input" id="endDate" name="endDate" value="">
        <button class="btn btn-secondary" onclick="clearChartDateFilters()"
            style="font-size: 10px; padding: 3px; border-radius: 5px;">clear</button>
    </div>
    <canvas id="myChart"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>

    const startDateInput = document.getElementById('startDate');
    const groupByElement = document.getElementById('periodSelect');
    startDateInput.value = getDateAgo(); // Set how many moth back want to load data
    const endDateInput = document.getElementById('endDate');
    let chartInstance = null;

    [startDateInput, endDateInput, groupByElement].forEach(input => {
        input.addEventListener('change', async () => {
            const startDate = startDateInput.value || null;
            const endDate = endDateInput.value || null;
            const groupBy = groupByElement.value || null;
            //console.log(`Start Date: ${startDate}, End Date: ${endDate}`);
            const chartData = await loadChartData(startDate, endDate, groupBy);
            if (chartData) {
                DrawChartData(chartData);
            }
        });
    });

    async function clearChartDateFilters() {
        startDateInput.value = getDateAgo();
        endDateInput.value = '';
        //groupByElement.value = 'weekly';
        groupByElement.selectedIndex = 1;
        const chartData = await loadChartData(startDate, endDate, groupByElement.value);
        if (chartData) {
            DrawChartData(chartData);
        }
    }

    //modify startdate / anddate on periodt select
    groupByElement.addEventListener("change", () => {
        switch (groupByElement.value) {
            case "daily":
                startDateInput.value = getDateAgo(1);
                break;
            case "monthly":
                startDateInput.value = getDateAgo(12);
                break;
            case "yearly":
                startDateInput.value = getDateAgo(36);
                break;
            default:
                startDateInput.value = getDateAgo(3);
        }
    });

    async function loadChartData(startDate = null, endDate = null, groupBy = null) {
        try {
            const response = await fetch(`${API_BASE_URL}/chart-data`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    start_date: startDate,
                    end_date: endDate,
                    groupBy: groupBy
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const responseData = await response.json();

            if (!responseData.success) {
                throw new Error(responseData.message || 'API returned error');
            }

            return responseData;
        } catch (error) {
            console.error('Error getting chart data:', error);
            return null;
        }
    }

    function calculateMaxYFromData(data) {
        const values = data.datasets.flatMap(ds => ds.data);
        const max = Math.max(...values);
        return Math.ceil(max / 5) * 5; // Round up to nearest 5%
    }

    function DrawChartData(chartData) {
        if (chartInstance) {
            chartInstance.destroy();
        }

        const ctxElement = document.getElementById('myChart');
        const ctx = ctxElement.getContext('2d');
        const maxY = calculateMaxYFromData(chartData.data);

        try {
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: chartData.data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            min: 0,
                            max: maxY, // dynamically set max
                            ticks: {
                                callback: value => value + '%'
                            }
                        }
                    }
                }
            });
        }
        catch (e) {
            console.error('Failed to initialize chart:', e);
        }
    }

    function setMaxYValue(maxValue) {
        if (chartInstance) {
            chartInstance.options.scales.y.max = maxValue;
            chartInstance.update();
        }
    }

    function getMaxYValue() {
        if (chartInstance) {
            return chartInstance.options.scales.y.max;
        }
        return 15; // Default value if chart is not initialized
    }

    // Initial chart load
    (async () => {
        const chartData = await loadChartData(startDateInput.value, endDateInput.value, groupByElement.value);
        if (chartData) {
            DrawChartData(chartData);
        }
    })();

    //get a date ago for determine start-date filter
    function getDateAgo(monthBack = 3) {
        const today = new Date();
        const threeMonthsAgo = new Date(today);

        threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - monthBack);

        // Handle edge case where day doesn't exist in the target month (e.g. May 31 â†’ Feb 28)
        if (threeMonthsAgo.getDate() !== today.getDate()) {
            // Adjust to last day of the previous month if overflowed
            threeMonthsAgo.setDate(0);
        }

        const year = threeMonthsAgo.getFullYear();
        const month = String(threeMonthsAgo.getMonth() + 1).padStart(2, '0');
        const day = String(threeMonthsAgo.getDate()).padStart(2, '0');

        return `${year}-${month}-${day}`;
    }

</script>